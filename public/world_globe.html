<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cyberpunk World Map</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // Interaction
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 1.5;
        controls.maxDistance = 4;

        // --- Globe ---
        const geometry = new THREE.IcosahedronGeometry(1, 4); // Radius 1, detail 4
        // Create wireframe logic manually to handle diagonal lines better or just use WireframeGeometry
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15 });
        const globe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        scene.add(globe);
        
        // Inner black sphere to block background stars behind the globe
        const blackSphereGeometry = new THREE.IcosahedronGeometry(0.99, 4);
        const blackSphereMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackSphere = new THREE.Mesh(blackSphereGeometry, blackSphereMaterial);
        scene.add(blackSphere);


        // --- Beacons ---
        const beacons = [];
        const beaconCount = 8;
        const beaconGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
        beaconGeometry.translate(0, 0.15, 0); // Pivot at base
        const beaconMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });

        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        for (let i = 0; i < beaconCount; i++) {
            const lat = (Math.random() - 0.5) * 160;
            const lon = (Math.random() - 0.5) * 360;
            const position = latLongToVector3(lat, lon, 1);
            
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.copy(position);
            beacon.lookAt(new THREE.Vector3(0,0,0)); // Point to center, so up is outward
            beacon.rotateX(-Math.PI / 2); // Correct orientation since lookAt points Z
            
            // Add pulse ring
            const ringGeo = new THREE.RingGeometry(0.02, 0.03, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.lookAt(new THREE.Vector3(0,0,0));
            // Slight offset to be above surface
            ring.position.add(position.clone().multiplyScalar(0.01));

            const beaconObj = { mesh: beacon, ring: ring, pulsePhase: Math.random() * Math.PI * 2 };
            beacons.push(beaconObj);
            scene.add(beacon);
            scene.add(ring);
        }

        // --- Stars Background ---
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i = 0; i < starsCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 20; // Spread out in space
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMaterial = new THREE.PointsMaterial({ size: 0.02, color: 0xffffff, transparent: true, opacity: 0.8 });
        const starMesh = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starMesh);


        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // Neon intensity
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Auto rotation
            globe.rotation.y += 0.001;
            blackSphere.rotation.y += 0.001;
            
            // Rotate beacons with the globe (manually since they aren't children)
            // Or better, put them in a group. Let's optimize:
            // But user said "Earth rotating", so simple group is better.
        }
        
        // Re-structure scene graph for easier rotation
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        globeGroup.add(globe);
        globeGroup.add(blackSphere);
        beacons.forEach(b => {
             globeGroup.add(b.mesh);
             globeGroup.add(b.ring);
        });

        const clock = new THREE.Clock();

        function render() {
            requestAnimationFrame(render);
            
            const delta = clock.getDelta();
            globeGroup.rotation.y += 0.0005; // Base rotation

            // Pulse Animation
            const time = clock.getElapsedTime();
            beacons.forEach(b => {
                // Pulse ring
                const scale = (Math.sin(time * 2 + b.pulsePhase) + 1) * 2 + 0.1; 
                const opacity = 1 - ((scale - 0.1) / 4); // Fade out as it expands
                
                b.ring.scale.set(scale, scale, 1);
                b.ring.material.opacity = Math.max(0, opacity);
                
                // Pulse beacon height slightly
                // b.mesh.scale.set(1, 1 + Math.sin(time * 5 + b.pulsePhase)*0.2, 1);
            });

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        render();
    </script>
</body>
</html>
